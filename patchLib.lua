--[[ HEX Patching methods ]] --

-- patch bytes by hex signature
function patchHex(hex, to)
    gg.searchNumber("h " .. hex, gg.TYPE_BYTE)
    gg.getResults(10000)
    gg.editAll("h " .. to, gg.TYPE_BYTE)
    gg.clearResults()
end

-- if the hex signature appears only once it's 100% safe
function isSafePatch(hex)
    gg.searchNumber("h " .. hex, gg.TYPE_BYTE)
    gg.getResults(10000)
    issafe = (#hex:gsub("%s+", "") / 2) == gg.getResultsCount()
    gg.clearResults()
    return issafe
end 


--[[ Offset Patching methods ]]--

-- prints bytes in HEX from offset
function printOffset(lib, addr, size)
    result = ""
    bytes = readOffset(lib, addr, size)
    for i = 1, #bytes do
        result = result .. string.format("%x", bytes[i]) .. " "
    end
    print(result)
end

-- reads HEX bytes from a lib by offset
function readOffset(lib, addr, size)
    local targetaddr = 0
    local targets = {}
    local result = {}
    for i, v in ipairs(gg.getRangesList(lib)) do
        if v.type:sub(3, 3) == "x" then
            targetaddr = v.start + addr
            break
        end
    end
    for i = 1, size do
        targets[#targets + 1] = {
            address = targetaddr + #targets,
            flags = gg.TYPE_BYTE
        }
    end
    for i, item in ipairs(gg.getValues(targets)) do
        result[i] = item.value & 0xff
    end
    return result
end

-- patches bytes in a lib by offset
function patchOffset(lib, addr, hex)
    local targetaddr = 0
    local patchCode = {}
    for i, v in ipairs(gg.getRangesList(lib)) do
        if v.type:sub(3, 3) == "x" then -- it's important to use this region
            targetaddr = v.start + addr
            break
        end
    end
    for code in string.gmatch(hex:gsub("%s+", ""), "..") do
        patchCode[#patchCode + 1] = {
            address = targetaddr + #patchCode,
            value = tonumber(code, 16),
            flags = gg.TYPE_BYTE
        }
    end
    gg.setValues(patchCode)
end
